#### jdk，jre，jvm的区别

JDK，JRE和JVM是Java开发和运行环境中的三个不同的概念，它们之间有以下区别：

1. JDK（Java Development Kit）：JDK是Java开发工具包，它包含了用于Java应用程序开发的工具和库，例如Java编译器（javac），Java虚拟机（JVM），Java标准库（Java API），以及其他的开发工具和实用程序。JDK是用于开发Java应用程序的完整软件包，包含了JRE的所有内容，并且还包含了用于编译Java源代码成为Java字节码的编译器。

2. JRE（Java Runtime Environment）：JRE是Java运行时环境，它是Java应用程序的运行环境，包含了Java虚拟机（JVM）和Java类库（Java API）。JRE只提供了Java应用程序运行所需的最小环境，不包含任何开发工具，如编译器和调试器。

   ![image-20230410033650589](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20230410033650589.png)

3. JVM（Java Virtual Machine）：JVM是Java虚拟机，它是Java程序在运行时的环境。JVM负责将Java字节码转换成机器码并执行，实现了Java程序的跨平台性，因为Java字节码是一种中间形式，可以在任何支持JVM的平台上运行。

简而言之，JDK是用于开发Java应用程序的完整工具包，包含了JRE和用于编译Java源代码的编译器；JRE是Java应用程序的运行时环境，包含了JVM和Java类库；而JVM是Java程序在运行时的虚拟机，负责将Java字节码转换成机器码并执行。

#### 面向对象有哪些特性？

面向对象四大特性：封装，继承，多态，抽象

1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。

2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。

3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。

- 静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。
- 动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。

4、抽象。把客观事物用代码抽象出来。

#### for与增强for区别，哪个快

在Java编程语言中，`for` 和增强型 `for`（也称为 `foreach`）是两种不同的循环语句。

`for` 循环是一种通用的循环结构，可以用于处理多种类型的循环需求。它由一个初始化部分、一个条件部分和一个迭代部分组成，可以在初始化部分定义循环计数器，并在条件部分指定循环终止的条件，迭代部分用于更新循环计数器的值。`for` 循环可以处理任意复杂度的循环逻辑，但需要手动处理集合或数组的索引、边界检查和迭代。

增强型 `for` 循环（`foreach`）是一种简化的循环结构，用于遍历集合或数组中的元素，它在 Java 5 中引入。增强型 `for` 循环不需要手动处理索引、边界检查和迭代，而是自动迭代集合或数组中的每个元素，从而简化了循环代码。增强型 `for` 循环使用更简洁的语法，但在遍历大型集合或数组时可能会略显低效，因为它会在每次迭代时都执行一次方法调用。

从性能角度来看，通常情况下，`for` 循环要比增强型 `for` 循环快。这是因为 `for` 循环对于集合或数组的访问方式更加灵活，可以在循环体中进行更多的优化，而增强型 `for` 循环则需要在每次迭代时进行方法调用，可能会导致一些性能开销。然而，在实际应用中，性能差异可能并不明显，因此在选择使用哪种循环结构时，应根据具体情况进行权衡，考虑代码的简洁性、可读性和性能需求。

#### String,StringBuilder,StringBuffer区别

​	(1)String是不可变字符串，每次改变都会产生新的对象

​		StringBuilder、StringBuffer可变字符串（多线程）

​			StringBuffer使用synchronized保证线程安全

​	(2)String、StringBuffer是线程安全,保证线程同步;StringBuilder非线程安全,不保证线程同步

​	(3)String不适合大量字符串的拼接,在JDK1.8时字符串常量拼接被自动优化成了StringBuilder

​		  StringBuilder适合单线程情况下大量字符串的拼接

​		  StringBuffer适合多线程大量字符串的拼接

​	(4)执行速度String(慢) < StringBuffer(较快) < StringBuilder(快)

​	(5)String[JDK1.0], StringBuffer[JDK1.0 ],StringBuilder[JDK1.5 ]

String存储在常量池，StringBuilder,StringBuffer存储在堆内存



 **可变性**

- String 不可变
- StringBuffer 和 StringBuilder 可变

**线程安全**

- String 不可变，因此是线程安全的
- StringBuilder 不是线程安全的
- StringBuffer 是线程安全的，内部使用 synchronized 进行同步



#### 深拷贝和浅拷贝

深克隆是指在复制对象或数据结构时，不仅复制了对象本身，还复制了对象所引用的所有子对象，形成一个完全独立的新对象。

浅克隆是指在复制对象或数据结构时，只复制了对象本身，而不复制对象所引用的子对象。新对象和原对象共享相同的子对象，即它们引用的是同一块内存空间。这意味着对新对象的修改可能会影响原对象，因为它们引用的是同一份数据。浅克隆通常比深克隆更快，因为它不需要复制整个对象的结构，但同时也可能导致意外的修改。

实现克隆的方法可以按照三步进行：

1. 实现Clonable接口；
2. 重写clone()方法。
3. 调用clone()方法克隆对象。

#### 深拷贝实现方式

1. 递归复制：递归地遍历原对象的每个属性和子属性，并为每个属性和子属性创建新的对象。这是一种常见的深拷贝实现方式，可以处理多层嵌套的对象结构。
2. 序列化和反序列化：将原对象序列化成一个字节流或字符串，然后再将序列化后的字节流或字符串反序列化成一个新的对象。这种方式利用了语言提供的序列化和反序列化功能，可以实现对象的深拷贝。
3. 使用第三方库：Java中也有一些第三方库，如Apache Commons Lang、Gson等，提供了方便的深拷贝功能。

#### Java的基本数据类型有哪些？

- byte，8bit
- char，16bit
- short，16bit
- int，32bit
- float，32bit
- long，64bit
- double，64bit
- boolean，只有两个值：true、false，可以使⽤用 1 bit 来存储

#### java的引用数据类型

在 Java 中，引用数据类型（也称为对象数据类型）是一种用于存储对象的数据类型，它指向对象在内存中的地址而不是实际的对象数据。Java 中的引用数据类型包括以下几种：

1. 类（Class）：是一种自定义的引用数据类型，通过类可以创建对象，并定义对象的属性和方法。
2. 接口（Interface）：是一种抽象的引用数据类型，定义了一组方法的规范，但不能直接创建对象，而是通过实现接口的类来创建对象。
3. 数组（Array）：是一种用于存储多个相同类型数据的引用数据类型，可以是一维数组、二维数组或多维数组。
4. 枚举（Enumeration）：是一种特殊的引用数据类型，用于定义一组具有固定值的常量，枚举类型在 Java 中是一种特殊的类。
5. 字符串（String）：是一种引用数据类型，用于表示字符串数据，Java 中的字符串是不可变的，即创建后不能修改。
6. 包装类（Wrapper Class）：是一种用于将基本数据类型封装成对象的引用数据类型，例如 Integer、Float、Boolean 等。

#### 了解Java的包装类型吗？为什么需要包装类？

Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int double 等类型放进去的。因为集合的容器要求元素是 Object 类型。

为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

#### 自动装箱和拆箱

Java中基础数据类型与它们对应的包装类见下表：

| 原始类型 | 包装类型  |
| :------- | :-------- |
| boolean  | Boolean   |
| byte     | Byte      |
| char     | Character |
| float    | Float     |
| int      | Integer   |
| long     | Long      |
| short    | Short     |
| double   | Double    |

装箱：将基础类型转化为包装类型。

拆箱：将包装类型转化为基础类型。

当基础类型与它们的包装类有如下几种情况时，编译器会**自动**帮我们进行装箱或拆箱：

- 赋值操作（装箱或拆箱）
- 进行加减乘除混合运算 （拆箱）
- 进行>,<,==比较运算（拆箱）
- 调用equals进行比较（装箱）
- ArrayList、HashMap等集合类添加基础类型数据时（装箱）

`Integer c = 200;` 会调用 调⽤`Integer.valueOf(200)`。而从Integer的valueOf()源码可以看到，这里的实现并不是简单的new Integer，而是用IntegerCache做一个cache。

这是IntegerCache静态代码块中的一段，默认Integer cache 的下限是-128，上限默认127。当赋值100给Integer时，刚好在这个范围内，所以从cache中取对应的Integer并返回，所以a和b返回的是同一个对象，所以`==`比较是相等的，当赋值200给Integer时，不在cache 的范围内，所以会new Integer并返回，当然`==`比较的结果是不相等的。

#### String 为什么不可变？

String对象其实在内部就是一个个字符，存储在这个value数组里面的。

value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。

String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。

所以，String是不可变的。

那为什么String要设计成不可变的？

主要有以下几点原因：

1. **线程安全**。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。
2. **支持hash映射和缓存**。因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。
3. **出于安全考虑**。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。
4. **字符串常量池优化**。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。

#### 堆和栈

在计算机科学中，"堆"（Heap）和"栈"（Stack）是两种用于管理内存的数据结构。

堆（Heap）是一块较大的内存区域，用于动态分配和管理内存。程序员可以在堆上分配和释放内存，这样可以在程序运行时动态地分配和管理内存空间。堆上分配的内存需要手动释放，否则会造成内存泄漏。

栈（Stack）是一种线性数据结构，它用于在程序执行期间保存临时数据。栈的操作是先进后出（LIFO）的，也就是最后进栈的数据最先出栈。栈的大小通常是固定的，并且在程序编译时就已经确定。栈上分配的内存会在其作用域结束时自动释放，不需要手动释放。

#### new String("dabin")会创建几个对象？

使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 "dabin" 这个字符串对象）。

- "dabin" 属于字符串字面量，因此编译时期会在字符串常量池中创建一个字符串对象，指向这个 "dabin" 字符串字面量；
- 使用 new 的方式会在堆中创建一个字符串对象。

#### equals和==有什么区别？

- #### 对于基本数据类型，==比较的是他们的值。基本数据类型没有equal方法；

- 对于复合数据类型，==比较的是它们的存放地址(是否是同一个对象)。`equals()`默认比较地址值，重写的话按照重写逻辑去比较。

#### Integer和int

lnteger存储在堆内存，默认值是null，是对象类型，封装了很多方法和属性

int类型是直接存储在栈空间默认值是0

#### Ajax的请求类型有哪些？

1.GET：一般应用于从服务器获取数据（给服务器的数据少，从服务器拿的数据多），一般使用URL问号传参的方式向服务器传递内容

2.POST：一般应用于向服务器推送数据（给服务器的多，从服务器拿下来的少），一般使用请求主体的方式向服务器传递内容

3.PUT：一般应用于给服务器上增加资源文件（上传图片功能），向服务器传输内容方式与POST一致

4.DELETE：一般应用于从服务器上删除资源文件，向服务器传输内容方式与get一致

5.HEAD：一般应用于只获取服务器的响应头信息，向服务器传输内容方式与get一致

#### GET和POST的主要区别

A.大小问题

GET请求传递给服务器的内容存在大小限制，而POST理论上没有限制：
原因：GET通过URL传参给服务器，每个浏览器对URL的长度都有限制，谷歌8kb，火狐7kb、IE2kb，所以最多传2kb（2048字节，一个汉字两个字节，一千多个汉字），如果URL的长度超过限制，浏览器会把超出部分截取；
POST理论上没有限制，但是一般控制在2M，具体也取决于服务器的设置和内存的大小

B.缓存问题

GET请求会出现缓存（这个缓存不一定是304），POST是没有缓存的
//在项目中GET请求一般不会让其出现缓存，于是应该在URL的末尾追加一个随机数清楚缓存

C.安全问题：
一般来书GET不安全，而POST相对安全一些
原因：GET是URL传参向服务器传递内容，可能被URL劫持

D.GET产生一个TCP数据包；POST产生两个TCP数据包

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

，也可以从服务器获取到数据，而一般提问中问到的区别都是开发人员约定俗成的规范：
