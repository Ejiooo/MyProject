#### 线程，进程，多线程

​		进程是指在系统中正在运行的一个应用程序，程序一旦运行就是进程。一个进程可以拥有多个线程。

​		线程是进程的一个实体，是进程的一条执行路径。线程是CPU独立运行和独立调度的基本单位。



![image-20221120232146884](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221120232146884.png)

![image-20221120232424715](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221120232424715.png)

#### 创建线程的方法

##### 1.继承Thread类

```java
public class TestThread1 extends Thread{
    @Override
    public void run() {
        //run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("非主线程---"+i);
        }
    }
    public static void main(String[] args) {
        //main线程，主线程
        //创建一个线程对象
        TestThread1 testThread1 = new TestThread1();
        //调用start()方法开启线程
        testThread1.start();

        for (int i = 0; i < 200; i++) {
            System.out.println("主线程---"+i);
        }
    }
}
```

<font color="red">不建议使用：避免OOP单继承局限性</font>

##### 2.实现Runnable接口

​		创建线程方式2︰实现runnable接口,重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。

```java
public class TestThread2 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println("run线程---"+i);
        }
    }
    public static void main(String[] args) {
        //创建runnable接口的实现类对象
        TestThread2 testThread2 = new TestThread2();
        //创建线程对象，通过线程对象来开启我们的线程，代理
        /*Thread thread = new Thread(testThread2);
        thread.start();*/
        new Thread(testThread2).start();

        for (int i = 0; i < 1000; i++) {
            System.out.println("主线程---"+i);
        }
    }
}
```

<font color="red">推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</font>

![image-20221120234854963](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221120234854963.png)



##### 3.实现Callable接口(了解)

1.实现Callable接口，需要返回值类型

2.重写call方法，需要抛出异常

3.创建目标对象

4.创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);

5.提交执行：Future<Boolean> result1 = ser.submit(t1);

6.获取结果： boolean r1 = result1.get()

7.关闭服务：ser.shutdownNow();

<font color="red">callable的好处：1.可以定义返回值。2.可以拗出异常。</font>

#### 静态代理

真实对象象和代理对象都要实现同一个接口

好处：

1.代理对可以做很多真实对象做不了的事情

2.真实对象专注做自己的事情

#### Lamda表达式

为什么要使用lambda表达式：

​	1.避免匿名内部类定义过多

​	2.可以让你的代码看起来很简洁

​	3.去掉了一堆没有意义的代码，只留下核心的逻辑。

![image-20221121001816996](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221121001816996.png)



#### 线程状态

![image-20221121225110278](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221121225110278.png)

![image-20221121225147867](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221121225147867.png)

##### 线程方法

| <font color="red">方法</font>  | <font color="red">说明</font>              |
| ------------------------------ | ------------------------------------------ |
| setPriority(int newPriority)   | 更改线程的优先级                           |
| static void sleep(long millis) | 在指定的毫秒数内让当前正在执行的线程休眠   |
| void join()                    | 等待该线程终止                             |
| static void yield()            | 暂停当前正在执行的线程对象，并执行其他线程 |
| void interrupt()               | 中断线程，别用这个方法                     |
| boolean isAlive()              | 测试线程是否处于活动状态                   |

##### 线程休眠

1.sleep(时间)指定当前线程阻塞的毫秒数

2.sleep存在异常InterruptedException

3.sleep时间达到后线程进入就绪状态

4.sleep可以模拟网络延时，倒计时等

5.每一个对象都有一个锁,sleep不会释放锁

##### 线程礼让

yield

1.礼让线程，让当前正在执行的线程暂停，但不阻塞

2.将线程从运行状态转为就绪状态

3.让cpu重新调度，礼让不一定成功!看CPU心情

##### Join

Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞

可以想象成插队

##### 线程状态观测

线程状态。线程可以处于以下状态之一:
NEW
尚未启动的线程处于此状态。

RUNNABLE
在Java虚拟机中执行的线程处于此状态。

BLOCKED
被阻塞等待监视器锁定的线程处于此状态。 

WAITING
正在等待另一个线程执行特定动作的线程处于此状态。

TIMED_WAITING
正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。

TERMINATED
已退出的线程处于此状态。

​        一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。

##### 线程的优先级

Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。

线程的优先级用数字表示，范围从1~10.

​		Thread.MIN_PRIORITY =1;

​		Thread.MAX_PRIORITY =10;

​		Thread.NORM_PRIORITY = 5;

使用以下方式改变或获取优先级

​		getPriority() . setPriority(int xxx)



##### 守护(daemon)线程

线程分为**用户线程**和**守护线程**

虚拟机必须确保用户线程执行完毕

虚拟机不用等待守护线程执行完毕

如：后台记录操作日志，监控内存，垃圾回收等待..



#### 使得线程阻塞有什么方式？ 使得线程死亡有什么方式？

使得线程阻塞的方式通常有以下几种：

1. 调用线程的 sleep() 方法：可以使线程休眠一段时间，进入阻塞状态。
2. 调用线程的 wait() 方法：可以使线程进入等待状态，直到其他线程调用该对象的 notify() 或 notifyAll() 方法来唤醒线程。
3. 调用线程的 join() 方法：可以使线程等待另一个线程执行完毕。
4. 获取锁失败：当线程试图获取某个对象的锁时，如果锁已经被其他线程占用，那么该线程会被阻塞，直到锁被释放。

使得线程死亡的方式通常有以下几种：

1. 线程的 run() 方法执行完毕：线程会自然结束并死亡。
2. 线程抛出未捕获的异常：当线程抛出未捕获的异常时，线程会终止并死亡。
3. 调用线程的 stop() 方法：虽然 stop() 方法可以使线程立即终止，但不推荐使用，因为它可能导致线程在不安全的状态下终止，导致资源泄漏或数据不一致的问题。在 Java 中，stop() 方法已被标记为过时。推荐使用其他方式来使线程正常退出。

#### 如何停止一个正在运行的线程？

有几种方式。

1、**使用线程的stop方法**。

使用stop()方法可以强制终止线程。不过stop是一个被废弃掉的方法，不推荐使用。

使用Stop方法，会一直向上传播ThreadDeath异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。

2、**使用interrupt方法中断线程**，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用interrupt方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。

接着调用 Thread.currentThread().isInterrupted()方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果isInterrupted返回true的话，会抛一个中断异常，然后通过try-catch捕获。

在中断线程时，线程会收到一个InterruptedException异常，可以在catch块中处理这个异常，并决定如何退出线程的执行。

需要注意的是，interrupt()方法并不会真正地终止线程的执行，而是会将线程的中断状态设置为true，需要在线程的执行逻辑中检查这个状态，并决定是否退出线程的执行。在线程中被中断的地方，可能需要做一些清理工作，例如关闭资源、释放锁等，以保证线程的安全退出。

3、**设置标志位**

设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用volatile修饰它，这样的话，变量取值始终会从主存中获取最新值。

但是这种volatile标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用Thread.sleep() 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。

因此，interrupt() 加上手动抛异常的方式是目前中断一个正在运行的线程**最为正确**的方式了。



#### 线程同步机制

多个线程操作同一个资源

并发：同一个对象被多个线程同时操作

​        处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个<font color="red">对象的等待池</font>形成队列，等待前面线程使用完毕，下一个线程再使用。

线程同步形成条件：**队列+锁**

​        由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问冲突问题。为了保证数据在方法中被访问时的正确性。在访问时加入锁机制<font color="red">synchronized</font>,当一个线程获得对象的排它锁,独占资源。其他线程必须等待，使用后释放锁即可。存在以下问题:

​	一个线程持有锁会导致其他所有需要此锁的线程挂起；

​	在多线程竞争下﹐加锁﹐释放锁会导致比较多的上下文切换和调度延时,引起性能问题；

​	如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置,引起性能问题。

#### 同步方法

​		由于我们可以通过private关键字来保证数据对象只能被方法访问﹐所以我们只需要针对方法提出一套机制,这套机制就是synchronized关键字，它包括两种用法︰synchronized方法和synchronized块。

```java
public synchronized void method(int args){}
```

​        synchronized方法控制对“对象”的访问。每个对象对应一把锁。每个synchronized方法都必须获得调用该方法的对象的锁才能执行。否则线程会阻塞，方法一旦执行﹐就独占该锁。直到该方法返回才释放锁。后面被阻塞的线程才能获得这个锁,继续执行

缺陷：若将一个大的方法申明为synchronized将会影响效率。



同步块：synchronized (Obj ){}

Obj称之为**同步监视器**

​		Obj可以是任何对象,但是推荐使用共享资源作为同步监视器

​		同步方法中无需指定同步监视器。因为同步方法的同步监视器就是this ,就是这个对象本身，或者是class[反射中讲解]

同步监视器的执行过程

1. 第一个线程访问,锁定同步监视器。执行其中代码。

   2.第二个线程访问。发现同步监视器被锁定。无法访问。

   3.第一个线程访问完毕。解锁同步监视器。

   4.第二个线程访问,发现同步监视器没有锁。然后锁定并访问。

#### 死锁

多个线程各自占有一些共享资源。并且互相等待其他线程占有的资源才能运行。而导致两个或者多个线程都在等待对方释放资源。都停止执行的情形。某一个同步块同时拥有“<font color="red">两个以上对象的锁“</font >”时，就可能会发生“死锁”的问题。

产生死锁的四个必要条件：

​	1.互斥条件：一个资源每次只能被一个进程使用。

​	2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

​	3.不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。

​	4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

#### Lock(锁)

​		从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

​		java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

​		ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。

如果同步代码有异常，要将unlock()写入finally语句块

##### synchronized 与Lock的对比

​	1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁，出了作用域自动释放

​	2.Lock只有代码块锁，synchronized有代码块锁和方法锁

​	3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)

​	4.优先使用顺序：

​			Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）

#### 线程通信

应用场景：生产者和消费者问题

​		假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库。消费者将仓库中产品取走消费。

​		如果仓库中没有产品,则生产者将产品放入仓库。否则停止生产并等待。直到仓库中的产品被消费者取走为止。

​		如果仓库中放有产品。则消费者可以将产品取走消费。否则停止消费并等待，直到仓库中再次放入产品为止。

​		**这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。**

​				对于生产者,没有生产产品之前。要通知消费者等待。而生产了产品之后，又需要马上通		知消费者消费。

​				对于消费者,在消费之后，要通知生产者已经结束消费。需要生产新的产品以供消费。

​				在生产者消费者问题中,仅有synchronized是不够的。

​						synchronized可阻止并发更新同一个共享资源，实现了同步。

​						synchronized 不能用来实现不同线程之间的消息传递(通信)。



线程间通信（Inter-thread Communication，简称IPC）是指在多线程编程中，不同线程之间进行信息传递和数据交换的方式。线程间通信是实现多线程协同工作和数据共享的重要手段，常用的线程间通信方式包括以下几种：

1. 共享内存：多个线程可以访问同一块共享内存区域，通过读写该内存区域来进行信息传递和数据共享。这种方式效率高，但需要开发者手动处理同步和互斥问题，以避免竞态条件等并发问题。
2. 互斥锁（Mutex）：互斥锁是一种同步原语，用于保护共享资源的访问，只允许一个线程进入临界区（Critical Section）执行操作。其他线程需要等待锁的释放才能访问共享资源，从而保证了线程间的互斥访问。
3. 信号量（Semaphore）：信号量是一种计数器，用于控制多个线程对共享资源的访问权限。可以有多个线程同时访问共享资源，但是需要根据信号量的值来判断是否可以进行访问。
4. 条件变量（Condition Variable）：条件变量用于线程之间的通知和等待。一个线程可以等待条件变量的某个条件成立，而另一个线程可以在满足条件时通过条件变量来通知等待的线程。
5. 管道（Pipe）：管道是一种单向的、半双工的通信方式，用于在具有亲缘关系的父子进程或者兄弟进程之间进行通信。可以通过管道在不同线程之间传递数据。
6. 消息队列（Message Queue）：消息队列是一种在不同线程之间传递消息的方式，线程可以将消息发送到队列中，而其他线程则可以从队列中接收消息。消息队列通常有缓冲区，可以在不同线程之间解耦发送和接收的速度。
7. RPC（Remote Procedure Call）：远程过程调用是一种通过网络在不同线程或不同进程之间进行通信的方式，类似于本地的函数调用。可以通过RPC调用远程线程或进程中的函数，并传递参数和获取返回值。

这些线程间通信方式在不同的场景和需求下有不同的适用性和优劣势，开发者需要根据实际情况选择合适的方式来进行线程间通信，以确保多线程编程的正确性和性能。

##### 解决方法

JAVA提供了几个方法解决线程之间的通信问题

| 方法名             | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| wait()             | 表示线程一直等待,直到其他线程通知，与sleep不同,会释放锁      |
| wait(long timeout) | 指定等待的毫秒数                                             |
| notify()           | 唤醒一个处于等待状态的线程                                   |
| notifyAll()        | 唤醒同一个对象上所有调用wait()方法的线程,优先级别高的线程优先调度 |

<font color='red'>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用,否则会抛出异常lllegalMonitorStateException。</font>

![image-20221122151921475](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221122151921475.png)

![image-20221122152127913](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20221122152127913.png)

#### wait()和sleep()的异同点？

**相同点**：

1. 它们都可以使当前线程暂停运行，把机会交给其他线程
2. 任何线程在调用wait()和sleep()之后，在等待期间被中断都会抛出`InterruptedException`

**不同点**：

1. `wait()`是Object超类中的方法；而`sleep()`是线程Thread类中的方法
2. 对锁的持有不同，`wait()`会释放锁，而`sleep()`并不释放锁
3. 唤醒方法不完全相同，`wait()`依靠`notify`或者`notifyAll `、中断、达到指定时间来唤醒；而`sleep()`到达指定时间被唤醒
4. 调用`wait()`需要先获取对象的锁，而`Thread.sleep()`不用

#### 线程run和start的区别？

- 当程序调用`start()`方法，将会创建一个新线程去执行`run()`方法中的代码。`run()`就像一个普通方法一样，直接调用`run()`的话，不会创建新线程。
- 一个线程的 `start()` 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常。`run()` 方法则没有限制。

#### start（）方法启动的时候干了什么？同步还是异步？

`start()` 方法通常用于启动一个新线程，使其开始执行对应的任务。这是一种异步的操作，因为主线程和新线程可以并行执行，互不阻塞。主线程继续执行后续的代码，而新线程则在后台执行任务。

#### 线程都有哪些方法？

**start**

用于启动线程。

**getPriority**

获取线程优先级，默认是5，线程默认优先级为5，如果不手动指定，那么线程优先级具有继承性，比如线程A启动线程B，那么线程B的优先级和线程A的优先级相同

**setPriority**

设置线程优先级。CPU会尽量将执行资源让给优先级比较高的线程。

**interrupt**

告诉线程，你应该中断了，具体到底中断还是继续运行，由被通知的线程自己处理。

当对一个线程调用 interrupt() 时，有两种情况：

1. 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。
2. 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true。不过，被设置中断标志的线程可以继续正常运行，不受影响。

interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。

**join**

等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

**yield**

暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

**sleep**

使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，线程自动转为Runnable状态。



#### 如何实现线程安全

在多线程编程中，线程安全是指在多个线程同时访问共享资源时，不会产生未定义的行为或数据错误。为了实现线程安全，需要采取一些措施来确保不会出现竞态条件（Race Condition）或其他多线程并发导致的问题。以下是一些实现线程安全的方法：

1. 互斥锁（Mutex）：互斥锁是一种最常用的线程同步机制，它可以确保同时只有一个线程能够访问共享资源。在访问共享资源之前，线程需要先获得互斥锁，如果互斥锁已经被其他线程占用，则线程会被阻塞，直到互斥锁被释放。
2. 读写锁（Reader-Writer Lock）：读写锁允许多个线程同时读取共享资源，但在写入共享资源时会阻塞其他线程的读取和写入操作。这可以提高并发性能，适用于读多写少的场景。
3. 原子操作（Atomic Operation）：原子操作是一种在单条指令中完成的操作，不会被其他线程中断，从而避免了竞态条件。例如，可以使用原子整数或原子指针来实现对共享计数器或标志位的安全访问。
4. 条件变量（Condition Variable）：条件变量用于线程间的通信和同步，允许一个或多个线程在满足特定条件时等待或唤醒。通过条件变量可以实现复杂的线程同步逻辑，例如生产者-消费者模型。
5. 线程安全的数据结构：选择使用线程安全的数据结构，例如线程安全的队列、哈希表、数组等，可以避免自己实现线程同步的复杂性。
6. 设计良好的并发算法：在设计多线程程序时，合理规划线程的执行顺序和同步点，避免竞态条件和死锁的发生。合理的程序设计可以减少线程同步的复杂性和错误。
7. 编写线程安全的代码：编写线程安全的代码需要考虑并发访问共享资源时可能出现的各种情况，并采取合适的同步措施。例如，避免共享数据的修改，使用局部变量代替全局变量，避免使用不可重入的函数等。

#### 如何在不加锁的情况下解决线程安全问题

1. 使用无锁数据结构：无锁数据结构是一种设计良好的数据结构，它可以在没有锁的情况下进行并发访问而不会导致竞态条件。例如，可以使用无锁队列、无锁哈希表等数据结构来处理共享资源，从而避免了锁的使用。
2. 使用原子操作：原子操作是一种可以在一个CPU周期内完成的操作，不会被中断，因此可以在多线程环境中安全地使用而不需要锁。例如，可以使用原子整数或者原子指针来进行并发访问，从而避免了锁的使用。
3. 使用线程局部存储（Thread-local storage）：线程局部存储是一种机制，允许每个线程都有自己的变量副本，不会被其他线程访问到。这样，每个线程都可以独立地修改自己的变量副本，而不需要锁来保护共享资源。
4. 使用读写锁：读写锁是一种特殊类型的锁，允许多个线程同时读取共享资源，但只有一个线程可以写入共享资源。这样可以减少锁的争用，提高并发性能。
5. 使用无共享状态设计：尽量避免在多线程环境中共享状态，而是将状态限制在单个线程内部。每个线程只访问自己的状态，不访问其他线程的状态，从而避免了锁的使用。

#### 线程的生命周期

**初始(NEW)**：线程被构建，还没有调用 start()。

**运行(RUNNABLE)**：包括操作系统的就绪和运行两种状态。

**阻塞(BLOCKED)**：一般是被动的，在抢占资源中得不到资源，被动的挂起在内存，等待资源释放将其唤醒。线程被阻塞会释放CPU，不释放内存。

**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。

**终止(TERMINATED)**：表示该线程已经执行完毕。

#### Runnable和Callable有什么区别？

- Callable接口方法是`call()`，Runnable的方法是`run()`；
- Callable接口call方法有返回值，支持泛型，Runnable接口run方法无返回值。
- Callable接口`call()`方法允许抛出异常；而Runnable接口`run()`方法不能继续上抛异常。

#### 线程执行顺序怎么控制？

假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？

可以使用**join方法**解决这个问题。比如在线程A中，调用线程B的join方法表示的意思就是**：A等待B线程执行完毕后（释放CPU执行权），在继续执行。**

#### 守护线程是什么？

守护线程是**运行在后台的一种特殊进程**。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。

#### ReentrantLock

ReentrantLock（可重入锁）是一种支持可重入性的锁。可重入性是指同一个线程可以多次获得同一把锁，而不会导致死锁。

当一个线程获得了ReentrantLock的锁之后，它可以继续多次调用lock()方法，而不会被阻塞，也不会导致死锁。每次调用lock()方法，锁的持有计数会增加，而每次调用unlock()方法，锁的持有计数会减少。只有当锁的持有计数变为0时，锁会被完全释放，其他线程才能够获得这把锁。

可重入性对于复杂的多线程编程场景非常有用，因为它允许线程在持有锁的情况下，调用其他方法或递归地调用同一方法，而无需担心死锁的问题。需要注意的是，当使用ReentrantLock时，线程必须在每次获得锁后，相应地在合适的时候释放锁，以确保锁的持有计数能够正确地增加和减少，从而保证可重入性的正确性。

#### ThreadLocal

线程本地变量。当使用`ThreadLocal`维护变量时，`ThreadLocal`为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程。

#### ThreadLocal原理

每个线程都有一个`ThreadLocalMap`（`ThreadLocal`内部类），Map中元素的键为`ThreadLocal`，而值对应线程的变量副本。

![image-20230410025831119](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20230410025831119.png)

`ThreadLocal`适合作为线程上下文变量，简化线程内传参。

#### ThreadLocal内存泄漏的原因？

每个线程都有⼀个`ThreadLocalMap`的内部属性，map的key是`ThreaLocal`，定义为弱引用，value是强引用类型。垃圾回收的时候会⾃动回收key，而value的回收取决于Thread对象的生命周期。一般会通过线程池的方式复用线程节省资源，这也就导致了线程对象的生命周期比较长，这样便一直存在一条强引用链的关系：`Thread` --> `ThreadLocalMap`-->`Entry`-->`Value`，随着任务的执行，value就有可能越来越多且无法释放，最终导致内存泄漏。

解决⽅法：每次使⽤完`ThreadLocal`就调⽤它的`remove()`⽅法，手动将对应的键值对删除，从⽽避免内存泄漏。

#### 锁的分类

##### 公平锁与非公平锁

按照**线程访问顺序**获取对象锁。`synchronized`是非公平锁，`Lock`默认是非公平锁，可以设置为公平锁，公平锁会影响性能。

##### 共享式与独占式锁

共享式与独占式的最主要**区别**在于：同一时刻独占式只能有**一个线程**获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。

##### 悲观锁与乐观锁

悲观锁，**每次访问资源都会加锁**，执行完同步代码释放锁，`synchronized`和`ReentrantLock`属于悲观锁。

乐观锁，不会锁定资源，所有的线程都能访问并修改同一个资源，如果没有冲突就修改成功并退出，否则就会继续循环尝试。乐观锁最常见的实现就是`CAS`。

适用场景：

- 悲观锁适合**写操作多**的场景。
- 乐观锁适合**读操作多**的场景，不加锁可以提升读操作的性能。

#### 乐观锁有什么问题?

乐观锁避免了悲观锁独占对象的问题，提高了并发性能，但它也有缺点:

- 乐观锁只能保证**一个共享变量**的原子操作。
- 长时间自旋可能导致**开销大**。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。
- **ABA问题**。CAS的原理是通过比对内存值与预期值是否一样而判断内存值是否被改过，但是会有以下问题：假如内存值原来是A， 后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变。可以引入版本号解决这个问题，每次变量更新都把版本号加一。

#### 什么是CAS？

CAS全称`Compare And Swap`，比较与交换，是乐观锁的主要实现方式。CAS在不使用锁的情况下实现多线程之间的变量同步。`ReentrantLock`内部的AQS和原子类内部都使用了CAS。

CAS算法涉及到三个操作数：

- 需要读写的内存值V。
- 进行比较的值A。
- 要写入的新值B。

只有当V的值等于A时，才会使用原子方式用新值B来更新V的值，否则会继续重试直到成功更新值。

以`AtomicInteger`为例，`AtomicInteger`的`getAndIncrement()`方法底层就是CAS实现，关键代码是 `compareAndSwapInt(obj, offset, expect, update)`，其含义就是，如果`obj`内的`value`和`expect`相等，就证明没有其他线程改变过这个变量，那么就更新它为`update`，如果不相等，那就会继续重试直到

####  CAS存在的问题？

CAS 三大问题：

1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从`A－B－A`变成了`1A－2B－3A`。

   JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，原子更新带有版本号的引用类型。

2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。

   Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作



#### 线程池

**@** 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。

**@** 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。

**@** 好处:

​		**@** 提高响应速度（减少了创建新线程的时间)

​		**@** 降低资源消耗（重复利用线程池中线程，不需要每次都创建)

​		**@** 便于线程管理(....)

​				**@** corePoolSize：核心池的大小

​				**@** maximumPoolSize：最大线程数

​				**@** keepAliveTime：线程没有任务时最多保持多长时间后会终止

**$ ** JDK 5.0起提供了线程池相关API：**ExecutorService**和**Executors**

**$ ** ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor

​	**$ **void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行	Runnable

​	**$ **<T> Future<T> submit(Callable<T> task):执行任务，有返回值，一般又来执行Callable

​	**$ **void shutdown():关闭连接池

​	**$ **Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池

#### 为什么平时都是使用线程池创建线程，直接new一个线程不好吗？

嗯，手动创建线程有两个缺点

1. 不受控风险
2. 频繁创建开销大

**为什么不受控**？

系统资源有限，每个人针对不同业务都可以手动创建线程，并且创建线程没有统一标准，比如创建的线程有没有名字等。当系统运行起来，所有线程都在抢占资源，毫无规则，混乱场面可想而知，不好管控。

**频繁手动创建线程为什么开销会大？跟new Object() 有什么差别？**

虽然Java中万物皆对象，但是new Thread() 创建一个线程和 new Object()还是有区别的。

new Object()过程如下：

1. JVM分配一块内存 M
2. 在内存 M 上初始化该对象
3. 将内存 M 的地址赋值给引用变量 obj

创建线程的过程如下：

1. JVM为一个线程栈分配内存，该栈为每个线程方法调用保存一个栈帧
2. 每一栈帧由一个局部变量数组、返回值、操作数堆栈和常量池组成
3. 每个线程获得一个程序计数器，用于记录当前虚拟机正在执行的线程指令地址
4. 系统创建一个与Java线程对应的本机线程
5. 将与线程相关的描述符添加到JVM内部数据结构中
6. 线程共享堆和方法区域

创建一个线程大概需要1M左右的空间（Java8，机器规格2c8G）。可见，频繁手动创建/销毁线程的代价是非常大的。

#### 为什么使用线程池？

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。统一管理线程，避免系统创建大量同类线程而导致消耗完内存。

#### 线程池执行原理？

![image-20230410031327298](C:\Users\WZ\AppData\Roaming\Typora\typora-user-images\image-20230410031327298.png)

1. 当线程池里存活的线程数小于核心线程数`corePoolSize`时，这时对于一个新提交的任务，线程池会创建一个线程去处理任务。当线程池里面存活的线程数小于等于核心线程数`corePoolSize`时，线程池里面的线程会一直存活着，就算空闲时间超过了`keepAliveTime`，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。
2. 当线程池里面存活的线程数已经等于corePoolSize了，这是对于一个新提交的任务，会被放进任务队列workQueue排队等待执行。
3. 当线程池里面存活的线程数已经等于`corePoolSize`了，并且任务队列也满了，假设`maximumPoolSize>corePoolSize`，这时如果再来新的任务，线程池就会继续创建新的线程来处理新的任务，知道线程数达到`maximumPoolSize`，就不会再创建了。
4. 如果当前的线程数达到了`maximumPoolSize`，并且任务队列也满了，如果还有新的任务过来，那就直接采用拒绝策略进行处理。默认的拒绝策略是抛出一个RejectedExecutionException异常。

#### 线程池参数有哪些？

1、核心线程数`corePoolSize`：表示线程池中同时运行的核心线程的数量。当线程池中的线程数小于核心线程数时，新任务会创建新线程来处理。核心线程会一直保持存活，即使它们处于闲置状态。

2、最大线程数`maximumPoolSize`：表示线程池中允许存在的最大线程数。当线程池中的线程数达到最大线程数时，新任务会被阻塞，直到有线程可用。最大线程数应该根据系统资源和性能需求来合理设置，避免线程过多导致资源竞争和性能下降。

3、`BlockingQueue`：存储等待运行的任务。

4、空闲线程存活时间`keepAliveTime`：**非核心线程**空闲后，保持存活的时间，此参数只对非核心线程有效。设置为0，表示多余的空闲线程会被立即终止。

5、`TimeUnit`：时间单位

6、`ThreadFactory`：每当线程池创建一个新的线程时，都是通过线程工厂方法来完成的。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建新线程就会调用它。

7、拒绝策略`RejectedExecutionHandler`：当队列和线程池都满了的时候，根据拒绝策略处理新任务。常见的拒绝策略包括抛出异常（AbortPolicy）、直接丢弃任务（DiscardPolicy）、丢弃最老任务（DiscardOldestPolicy）和自定义策略。

#### 线程池有哪些状态

线程池是一种用于管理多线程的并发编程技术，它通常由一组预先创建的线程组成，可以在需要时分配给任务，以避免频繁地创建和销毁线程，从而提高程序的性能和效率。线程池中的线程可以处于不同的状态，以下是常见的线程池状态：

1. 空闲（Idle）：线程处于空闲状态，等待新的任务分配。
2. 运行（Running）：线程正在执行任务。
3. 阻塞（Blocked）：线程在等待某些条件满足时被阻塞，例如等待I/O操作完成或等待锁释放。
4. 等待（Waiting）：线程正在等待某些条件满足，但在等待期间不会参与竞争，例如调用了线程的wait()方法。
5. 超时等待（Timed Waiting）：线程在等待某些条件满足时，设定了一个超时时间，超过该时间后会自动唤醒，例如调用了线程的sleep()方法或带有超时参数的wait()方法。
6. 终止（Terminated）：线程执行完任务并终止，或因异常等原因被强制终止。

这些是线程池中常见的状态，不同的编程语言和操作系统可能会有一些特定的状态。线程池状态的管理对于线程池的性能和稳定性至关重要，需要合理地管理线程的生命周期，避免线程的死锁、饥饿等问题。

#### 怎么判断线程池的任务是不是执行完了？

有几种方法：

1、使用线程池的原生函数**isTerminated()**;

executor提供一个原生函数isTerminated()来判断线程池中的任务是否全部完成。如果全部完成返回true，否则返回false。

2、**使用重入锁，维持一个公共计数**。

所有的普通任务维持一个计数器，当任务完成时计数器加一（这里要加锁），当计数器的值等于任务数时，这时所有的任务已经执行完毕了。

3、**使用CountDownLatch**。

它的原理跟第二种方法类似，给CountDownLatch一个计数值，任务执行完毕后，调用countDown()执行计数值减一。最后执行的任务在调用方法的开始调用await()方法，这样整个任务会阻塞，直到这个计数值为零，才会继续执行。

这种方式的**缺点**就是需要提前知道任务的数量。

4、**submit向线程池提交任务，使用Future判断任务执行状态**。

使用submit向线程池提交任务与execute提交不同，submit会有Future类型的返回值。通过future.isDone()

#### 什么是Future？

在并发编程中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。

Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。

举个例子：比如去吃早点时，点了包子和凉菜，包子需要等3分钟，凉菜只需1分钟，如果是串行的一个执行，在吃上早点的时候需要等待4分钟，但是因为你在等包子的时候，可以同时准备凉菜，所以在准备凉菜的过程中，可以同时准备包子，这样只需要等待3分钟。Future就是后面这种执行模式。

Future接口主要包括5个方法：

1. get()方法可以当任务结束后返回一个结果，如果调用时，工作还没有结束，则会阻塞线程，直到任务执行完毕
2. get(long timeout,TimeUnit unit)做多等待timeout的时间就会返回结果
3. cancel(boolean mayInterruptIfRunning)方法可以用来停止一个任务，如果任务可以停止（通过mayInterruptIfRunning来进行判断），则可以返回true，如果任务已经完成或者已经停止，或者这个任务无法停止，则会返回false。
4. isDone()方法判断当前方法是否完成
5. isCancel()方法判断当前方法是否取消

